# Приложение для получения списка населённых пунктов с информацией о вакансиях.
# Если вакансий нет - то и дальнейшая работа с данным населённым пунктом
# останавливается, так как не имее смысла. Хотя можно было бы и про эти населённые
# пункты написать, что там нет вакансий. Но это не имеет смысла. Информация о населённых
# пунктах в настоящеее время выводится в файл vacancies_lst.txt.
# Имеется резервный файл vacancies_lst_base_version.txt. Формат записи очевиден:
#
#   Номер записи
#           имя населённого пункта :
#                       количество вакансий
#
#  Данные из этого файла применяются при выполнении приложений, где требуется информация
#  о регионах с непустыми множествами записей о вакансиях.

# Импорт необходимых для работы библиотек:

import requests      # Для запросов по API
import json          # Для обработки полученных результатов
import os            # Для работы с файлами
import pandas as pd  # Для формирования датафрейма с результатами
                     # (как-то не склалось)

import time

# получение всех стран со всеми их внутренними зонами:
def getAreas(keyId):
    # регионы со своими внутренними зонами
    req = requests.get('https://api.hh.ru/areas')
    data = req.content.decode()
    req.close()
    # прочитали все req и преобразовали их в data
    jsObj = json.loads(data)
    areas = [] # всё готово к сбору информации о зонах (список зон объявлен)
               # areas и 'areas' это список и ключ в словаре зон -
               # большая разница!
    # ====================================================================
    for k in jsObj:
    # теперь в k отдельный объект из jsObj по структуре это списк.
    # Возможно, что пустой. И в k как в обычном списке могут быть другие
    # зоны (списки списков). Эти зоны разбираются и если список не пустой,
    # то это значит, что у зоны есть свои внутренние зоны, которые надо разобрать.
        # ================================================================
        for i in range(len(k['areas'])):
            # ============================================================
            if len(k['areas'][i]['areas']) != 0: # словарь не пустой.У зоны есть
                # внутренние зоны. И тогда внутренние зоны аналогичным образом разбираются
                # и цепляются к списку areas
                for j in range(len(k['areas'][i]['areas'])):
                    # ==== и так будет с каждой зоной ====================
                    if k['id'] == keyId:
                        areas.append([k['id'],
                                      k['name'],
                                      k['areas'][i]['areas'][j]['id'],
                                      k['areas'][i]['areas'][j]['name']])
                    # ====================================================
                    # из словаря получается список значений.
                    # Ключи не нужны. Здесь достаточно того, что каждое значение
                    # в записи зоны строго упорядочено
            # ============================================================
            else:                                # Если у зоны нет внутренних зон -
                                                 # она к списку зон цепляется сама
                # ==== и так будет с каждой зоной ====================
                if k['id'] == keyId:
                    areas.append([k['id'],
                                  k['name'],
                                  k['areas'][i]['id'],
                                  k['areas'][i]['name']])
                # ====================================================
                # из словаря получается список значений.
                # Ключи не нужны. Здесь достаточно того, что каждое значение
                # в записи зоны строго упорядочено

    return areas    # на выходе - список разобранных зон


# Для примера 2ГИС с ID 64174 и найдем все вакансии по работодателю в каждой зоне России (ID 113).
# В функцию getPage в качестве входных параметров только номер страницы для постраничного поиска и зона,
# где будут собираться вакансии.

def getPage(n_page, area):
    #               зона, где будут собираться вакансии
    #      номер страницы для постраничного вакансий

    # словарь с параметрами поиска
    params = {
        #'employer_id': 3529,  # СБЕР
        'area': area,         # Поиск в зоне
        'page': n_page,       # Номер страницы
        #'per_page': 10       # Количество вакансий на 1 странице
    }

    # вакансии по работодателю по каждой зоне России (ID 113)
    req = requests.get('https://api.hh.ru/vacancies', params)
    data = req.content.decode()
    req.close()
    return data



# ========================================================================
def findPages(areas, f):


    global v
    if not os.path.exists('./areas/'):
        os.makedirs('./areas/')

    area_number = -1    # !!!!!
    # ============================================================

    for area in areas:

        area_number+=1
        #print(f'{area_number} ... {area}')
        # вакансии по работодателю в каждой зоне России (ID 113) =========
        # area[0]   area[1]     area[2]                 area[3]
        # '113'     Россия      ещё код (региона?)...   населённый пункт

        # УКАЗАТЕЛЬ количества прочитанных (прочитанных с шагом 'per_page')
        # страниц с вакансиями для данного региона
        page = 0

        while True:

            # с помощью java script object notation (json) функцией
            # getPage(номерСтраницы, кодРегиона)
            # формируются записи о вакансиях по данному коду Региона.
            # Возможны записи с пустыми списками ([] или None).
            # Их надо будет записывать
            # в файл регионов с пометкой "пустой список вакансий" после этого
            # производится выбор новой зоны.
            # Там же увеличивается значение счётчика area_number

            jsObj = json.loads(getPage(page, area[2]))
            # аргумент page обеспечивает постраничное чтение: страница,
            # зона поиска, ... значение 'per_page': ... можно установить
            # ПО УМОЛЧАНИЮ.


            time.sleep(0.50)   # таймер обеспечивает стабильную работу
                               # оператора json.loads...

            vacancyJob = None

            # Попытка перебора списка вакансий. Этот список может быть
            # непустым и корректно заполненным, может быть пустым, может
            # быть пустым и содержать ошибки заполнения (плохо прочитан).

            try:
                vacancyJob = jsObj['items']
            except Exception as ex:

                print(f'{page}:  {area_number} ..... {vacancyJob} :::::: {ex} ..... ')
                # if page == 0:
                #     print(f'{area_number}: {area[3]} vacancyJob is empty ???')
                    #f.write(f'{area_number} {area[3]} ошибка\n')
                    # при правильно подобранном значении таймера ошибок не происходит.
                    # json.loads правильно отрабатывает и возвращает корректный jsObj.
                break
                # из jsObj прочитано всё, что возможно (скорее всего НИЧЕГО прочесть
                # не получилось). Можно выходить из цикла

            # ну вот как раз тот самый случай, когда корректный список вакансий
            # региона изначально пустой. Здесь можно было бы воспользоваться
            # функцией len(vacancyJob) == 0, но такой оператор сравнения нагляднее.
            if vacancyJob == [] :
                if page == 0:

                    print(f'{area_number}: {area[3]} vacancyJob is empty !')
                    #f.write(f'{area_number} {area[3]} ПУСТАЯ запись \n')

                break
                # из jsObj прочитано всё, что возможно. Можно выходить из цикла

            elif vacancyJob != [] :
            # а это разбор корректного списка вакансий
                v=0    # !!!!!

                for vc in vacancyJob:

            #         # разбор страниц с информацией о вакансиях ===============
            #         # с подсчётом количества страниц (для продолжения чтения)
            #         # и записей о вакансиях в прочитанной странице ===

                    v += 1    # это счётчик записей о вакансиях в
                              # корректном списке вакансий

            # ========================================================
            #
            #     # вывод информации о вакансиях в формате
            #     #
            #     #     номер_записи
            #     #           название населённого пункта
            #     #               номер страницы
            #     #
            #     # перед этим выводится информация об области, в которой будет
            #     # собираться информация о вакансиях.
            #     # Это приложение не предназначается для "коммерческого"
            #     # применения! И в этом случае такое представление
            #     # информации о вакансиях кажется более НАГЛЯДНЫМ (количество
            #     # страниц зависит от количества читаемых за один раз записей)!
            #
                    # print(f'{area_number} {area[3]}  {v}')
                    # f.write(f'{area_number} {area[3]}:  {v}\n')

                page+=1     # и можно попытаться прочесть ещё ОДНУ страницу:
                            # getPage(page, area[2]) вызвать с новым значением
                            # параметра page

            print(f'{area_number} {area[3]} {v}')
            f.write(f'{area_number} {area[3]} {v}\n')

        #break
# ============================================================================================

# выбор области
areas = getAreas('113')

# составление списка регионов с вакансиями
f = open('q_vacancies_lst.txt', mode='w', encoding='utf8')
findPages(areas, f)
f.close()








