# список более 8000 населённых пунктов со списками вакансий по максимому
# с работодателями (без комментариев)

import requests      # Для запросов по API
import json          # Для обработки полученных результатов
import os            # Для работы с файлами

import time

# получение всех стран со всеми их внутренними зонами:
def getAreas(keyId):
    # регионы со своими внутренними зонами
    req = requests.get('https://api.hh.ru/areas')
    data = req.content.decode()
    req.close()
    # прочитали все req и преобразовали их в data
    jsObj = json.loads(data)
    areas = [] # всё готово к сбору информации о зонах (список зон объявлен)
               # areas и 'areas' это список и ключ в словаре зон -
               # большая разница!
    # ====================================================================
    for k in jsObj:
    # теперь в k отдельный объект из jsObj по структуре это списк.
    # Возможно, что пустой. И в k как в обычном списке могут быть другие
    # зоны (списки списков). Эти зоны разбираются и если список не пустой,
    # то это значит, что у зоны есть свои внутренние зоны, которые надо разобрать.
        # ================================================================
        for i in range(len(k['areas'])):
            # ============================================================
            if len(k['areas'][i]['areas']) != 0: # словарь не пустой.У зоны есть
                # внутренние зоны. И тогда внутренние зоны аналогичным образом разбираются
                # и цепляются к списку areas
                for j in range(len(k['areas'][i]['areas'])):
                    # ==== и так будет с каждой зоной ====================
                    if k['id'] == keyId:
                        areas.append([k['id'],
                                      k['name'],
                                      k['areas'][i]['areas'][j]['id'],
                                      k['areas'][i]['areas'][j]['name']])
                    # ====================================================
                    # из словаря получается список значений.
                    # Ключи не нужны. Здесь достаточно того, что каждое значение
                    # в записи зоны строго упорядочено
            # ============================================================
            else:                                # Если у зоны нет внутренних зон -
                                                 # она к списку зон цепляется сама
                # ==== и так будет с каждой зоной ====================
                if k['id'] == keyId:
                    areas.append([k['id'],
                                  k['name'],
                                  k['areas'][i]['id'],
                                  k['areas'][i]['name']])
                # ====================================================
                # из словаря получается список значений.
                # Ключи не нужны. Здесь достаточно того, что каждое значение
                # в записи зоны строго упорядочено

    return areas    # на выходе - список разобранных зон


# Для примера 2ГИС с ID 64174 и найдем все вакансии по работодателю в каждой зоне России (ID 113).
# В функцию getPage в качестве входных параметров только номер страницы для постраничного поиска и зона,
# где будут собираться вакансии.

def getPage(n_page, area):
    #               зона, где будут собираться вакансии
    #      номер страницы для постраничного вакансий

    # словарь с параметрами поиска
    params = {
        #'employer_id': 3529,  # СБЕР
        'area': area,         # Поиск в зоне
        'page': n_page,       # Номер страницы
        'per_page': 100       # Количество вакансий на 1 странице
    }

    # вакансии по работодателю по каждой зоне России (ID 113)
    req = requests.get('https://api.hh.ru/vacancies', params)
    data = req.content.decode()
    req.close()
    return data



# ========================================================================
def findPages(areas, f):


    if not os.path.exists('./areas/'):
        os.makedirs('./areas/')

    area_number = -1    # !!!!!
    global vac_string
    # ============================================================

    for area in areas:

        area_number+=1
        #print(f'{area_number} ... {area}')
        # вакансии по работодателю в каждой зоне России (ID 113) =========
        # area[0]   area[1]     area[2]                 area[3]
        # '113'     Россия      ещё код (региона?)...   населённый пункт

        # УКАЗАТЕЛЬ количества прочитанных (прочитанных с шагом 'per_page')
        # страниц с вакансиями для данного региона
        page = 0

        while True:

            # с помощью java script object notation (json) функцией
            # getPage(номерСтраницы, кодРегиона)
            # формируются записи о вакансиях по данному коду Региона.
            # Возможны записи с пустыми списками ([] или None).
            # Их надо будет записывать
            # в файл регионов с пометкой "пустой список вакансий" после этого
            # производится выбор новой зоны.
            # Там же увеличивается значение счётчика area_number

            jsObj = json.loads(getPage(page, area[2]))
            # аргумент page обеспечивает постраничное чтение: страница,
            # зона поиска, ... значение 'per_page': ... можно установить
            # ПО УМОЛЧАНИЮ.


            time.sleep(0.5)   # таймер обеспечивает стабильную работу
                               # оператора json.loads...

            vacancyJob = None

            # Попытка перебора списка вакансий. Этот список может быть
            # непустым и корректно заполненным, может быть пустым, может
            # быть пустым и содержать ошибки заполнения (плохо прочитан).

            try:
                vacancyJob = jsObj['items']
            except Exception as ex:
                print(f'- {page}')
                # print(f'{page}:  {area_number} ..... {vacancyJob} :::::: {ex} ..... ')
                # if page == 0:
                #     print(f'{area_number}: {area[3]} vacancyJob is empty ???')
                #     # при правильно подобранном значении таймера ошибок не происходит.
                    # json.loads правильно отрабатывает и возвращает корректный jsObj.
                break
                # из jsObj прочитано всё, что возможно (скорее всего НИЧЕГО прочесть
                # не получилось). Можно выходить из цикла

            # ну вот как раз тот самый случай, когда корректный список вакансий
            # региона изначально пустой. Здесь можно было бы воспользоваться
            # функцией len(vacancyJob) == 0, но такой оператор сравнения нагляднее.

            if vacancyJob == [] :
                if page == 0:
                    print(f'{area_number} ?')
                    #print(f'{area_number}: {area[3]} vacancyJob is empty !!!')
                    #f.write(f'{area_number} {area[3]} vacancyJob is empty \n')
                    xxx = -1
                break
                # из jsObj прочитано всё, что возможно. Можно выходить из цикла

            elif vacancyJob != [] :
                # а это разбор корректного списка вакансий


                for vc in vacancyJob:
                    vac_string = vc['name'] + ' - ' + vc['employer']['name']
                    # разбор страниц с информацией о вакансиях ===============
                    # с подсчётом количества страниц (для продолжения чтения)
                    # и записей о вакансиях в прочитанной странице ===



                # ========================================================

                # вывод информации о вакансиях в формате
                #       номер_записи
                #           населённый_пункт
                #               вакансия
                #                   наниматель

                # такое представление информации о вакансиях представляется
                # более НАГЛЯДНЫМ а вообще, количество страниц зависит
                # от количества читаемых за один раз записей


                    #print(f'{area_number} {area[3]}:  {vac_string}')
                    f.write(f'{area_number} {area[3]}: {vac_string}\n')



                page+=1     # и можно попытаться прочесть ещё ОДНУ страницу:
                            # getPage(page, area[2]) вызвать с новым значением
                            # параметра page
                print(f'{area_number} {page} {area[3]}')


# ============================================================================================

# выбор области
areas = getAreas('113')

# составление списка регионов с вакансиями
f = open('empl_0_vacancies_lst.txt', mode='w', encoding='utf8')
findPages(areas, f)
f.close()








